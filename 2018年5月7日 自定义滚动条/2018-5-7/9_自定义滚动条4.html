<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
<style>
*{
    margin: 0;
    padding:0;
}
#div1{
    width:50px;
    height: 300px;
    background: #000;
    position: relative;
    float: left;
}
#div2{
    width:50px;
    height: 50px;
    position:absolute;
    top:0;
    left:0;
    background: red;
}
#div3{
    float: left;
    width:300px;
    height: 300px;
    border: 1px solid #000;
    position: relative;
    overflow: hidden;
}
#div4{
    position: absolute;
    top:0;
    left:0;
}
</style>
</head>
<body>
    <div id="div1">
        <div id="div2"></div>
    </div>
    <div id="div3">
        <div id="div4">
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                
        </div>
    </div>
<script>
    /*
        自定义滚动条
            1.比例公式
            2.事件对象的相关知识
            
        扩展:
            1.如果内容在box3的可视区范围就不出现滚动条
            2.动态生成滚动条
                滚动条的高度跟内容有关系
                    内容越多，滚动条越小反之越大

    */
    const box1 = document.getElementById('div1');
    const box2 = document.getElementById('div2');
    const box3 = document.getElementById('div3');
    const box4 = document.getElementById('div4');

    //div3的高度
    let box3H = box3.clientHeight;

    //div4的被内容撑开的高度
    let box4H = box4.scrollHeight;

    //div1的高度
    let box1H = box1.clientHeight;

    if(box3H >= box4H){
        box1.style.display = 'none';
    }else{
        box1.style.display = 'block';
        /*
            box2的高度 = (box3H / box4H) * 滚动条的高度

            内容越多，滚动条越小反之越大
        */
        let scale2 = (box3H / box4H);
        if(scale2 < .1)scale2 = .1;
        box2.style.height = scale2 * box1H + 'px';

    }
    box2.addEventListener('mousedown',function(ev){
        let disY = ev.pageY - this.offsetTop;

        let move = function(ev){
            let t = ev.pageY - disY;
            if(t < 0){
                t = 0;
            }else if(t > box1H - box2.clientHeight){
                t = box1.clientHeight - box2.clientHeight;
            }
            
            let scale = t/(box1.clientHeight - box2.clientHeight)
            
            

           
            
            box4.style.top = scale * (box3H - box4H) + 'px';

            box2.style.top = t + 'px';
        }

        let up = function(){
            document.removeEventListener('mousemove',move);
            document.removeEventListener('mouseup',up);
        }

        document.addEventListener('mousemove',move);
        document.addEventListener('mouseup',up);
        ev.preventDefault();
    }); 


    let timer = null;
    box1.onmousedown = function(ev){
        timer = setInterval(function(){
            //向上
            let t = box2.offsetTop;
            if(ev.pageY < t){
                t -= 5;
                // box2.style.top = t + 'px'; 
            }else if(ev.pageY > box2.getBoundingClientRect().bottom){
                //向下
                t += 5;
               
            }else{
                //box2的位置和down的位置相等就说明到了目标点了
                clearInterval(timer);
            }
            let scale = t/(box1.clientHeight - box2.clientHeight)
            
            box4.style.top = scale * (box3H - box4H) + 'px';
            box2.style.top = t + 'px'; 
            console.log(1);
        },16.7);
    }

    box1.onmouseup = function(ev){
        clearInterval(timer);
    }

</script>
</body>
</html>