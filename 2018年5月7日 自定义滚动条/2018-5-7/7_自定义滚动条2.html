<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
<style>
*{
    margin: 0;
    padding:0;
}
#div1{
    width:50px;
    height: 300px;
    background: #000;
    position: relative;
    float: left;
}
#div2{
    width:50px;
    height: 50px;
    position:absolute;
    top:0;
    left:0;
    background: red;
}
#div3{
    float: left;
    width:300px;
    height: 300px;
    border: 1px solid #000;
    position: relative;
    overflow: hidden;
}
#div4{
    position: absolute;
    top:0;
    left:0;
}
</style>
</head>
<body>
    <div id="div1">
        <div id="div2"></div>
    </div>
    <div id="div3">
        <div id="div4">
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

                33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。
                
                33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。
                
                33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图
                
                33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。
                
                33.6 - Vue语法从零到熟练
                
                33.6.1 - Vue的两大特点
                
                33.6.1.1 - 响应式数据绑定：数据的增删改查都是可被watch的，一旦变动自动更新视图
                
                33.6.1.2 - 可组合的视图组件：把页面拆成多组件，可达到封装、复用、可测试的目的
                
                33.6.2 - 声明式渲染
                
                33.6.2.1 - 描述要什么样子，让框架帮你做
                
                33.6.2.2 - 声明模板语法将实例数据进行绑定
                
                33.6.2.3 - 模板语法-插值：采用“Mustache”语法{{表达式|实例数据}}
                
                33.6.2.4 - 把注意力全身心的投入到业务逻辑的数据处理上，而无需手动变动DOM的更新
                
                33.6.3 - 指令
                
                33.6.3.1 - 自定义属性，写在标签上以v-为前缀的特殊属性
                
                33.6.3.2 - 预期的值为javascript表达式
                
                33.6.3.3 - 作用是将数据和DOM做关联，当表达式的值改变时，响应式地作用于DOM上
                
                33.6.4 - 常用指令一览
                
                33.6.4.1 - v-bind：动态的绑定数据到DOM元素上，当数据发生变化，响应的更新DOM数据
                
                33.6.4.2 - v-once：只渲染元素和组件一次，随后数据更新，并不会重新更新DOM数据，可视为静态内容，将渲染结果缓存起来，用于优化更新性能
                
                33.6.4.3 - v-show：根据表达式之真假值，切换元素的 display CSS 属性
                
                33.6.4.4 - v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建
                
                33.6.4.5 - v-if、v-else-if、v-else：多重条件选择渲染
                
                33.6.4.6 - v-for：基于源数据多次渲染元素或模板块；v-for默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性：
                
                33.6.4.7 - v-model：随表单控件类型不同而不同，在表单控件或者组件上创建双向绑定
                
                33.6.4.8 - v-cloak：以隐藏未编译的 Mustache 标签直到实例准备完毕
                
                33.6.4.9 - v-once：只渲染元素和组件一次，这可以用于优化更新性能
                
                33.6.4.10 - 自定义指令：除了核心功能默认内置的指令，也允许注册自定义指令
                
                33.6.5 - 选项对象
                
                33.6.5.1 - 在启动整个应用实例化时传入的参数。通过这些选项来创建想要的行为
                
                33.6.5.2 - el（element）：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标
                
                33.6.5.3 - 数据类：
                
                33.6.5.3.1 - data（数据）：应用的数据，可被转为getter/setter，能够响应数据的变化
                
                33.6.5.3.2 - computed（计算属性）：将对data数据的逻辑抽离在计算属性中；这些属性依赖data的变化而相应；计算属性的结果会被缓存，多次使用不重新计算。
                
                33.6.5.3.3 - methods（方法）：存放应用中封装的方法，例如事假处理函数
                
                33.6.5.3.4 - watch（侦听属性）：当有一些数据需要随着其它数据变动而变动时，可通过watch侦听
                
                33.6.5.3.5 - computed VS methods VS watch watch：这三者在某些功能点是重复的，何时使用使用在什么样的场景。
                
                33.6.5.4 - 生命周期钩子函数
                
                33.6.5.4 - 生命周期钩子函数
                
                33.6.5.4.2 - created：实例创建完成后被立即调用，数据观测，计算属性，方法定义都已完成，但还没开始挂载。
                
                33.6.5.4.3 - beforeMount：挂载开始之前被调用
                
                33.6.5.4.4 - mounted：挂载之后调用该钩子函数
                
                33.6.5.4.5 - beforeUpdate：数据更新时调用，可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程
                
                33.6.5.4.6 - updated：数据更新之后调用该函数，当这个钩子被调用时，组件 DOM 已经更新
                
                33.6.5.4.7 - beforeDestroy：实例销毁之前调用
                
                33.6.5.4.8 - destroyed：实例销毁后调用，调用后实例中所有东西都会解除绑定，子实例也会被销毁
                
                33.6.6 - 组件
                Vue是一个构建数据驱动的Web界面的库，通过简单的API提供高效的数据绑定和灵活的组件系统。

33.2 - Vue具有简洁、轻量、快速、 数据驱动、 组件化等特点，除此之外，Vue还具有上手快，简单易学，学完即用，快速开发的优势。

33.3 - 可把页面组件化、模块化，分工明确，互不干涉，低耦合的设计使组件可复用、可测试，更易于维护。

33.4 - 响应式编程，开发者只需要聚焦在状态的逻辑处理上，让框架来进行DOM操作，不需要自己手动更新视图

33.5 - 官方提供健全的周边工具，例如vue-cli创建项目目录和开发环境配置、vue-router前端路由创建单页应用、vuex集中式应用状态管理器。

33.6 - Vue语法从零到熟练

33.6.1 - Vue的两大特点

33.6.1.1 - 响应式数据绑定：数据的增删改查都是可被watch的，一旦变动自动更新视图

33.6.1.2 - 可组合的视图组件：把页面拆成多组件，可达到封装、复用、可测试的目的

33.6.2 - 声明式渲染

33.6.2.1 - 描述要什么样子，让框架帮你做

33.6.2.2 - 声明模板语法将实例数据进行绑定

33.6.2.3 - 模板语法-插值：采用“Mustache”语法{{表达式|实例数据}}

33.6.2.4 - 把注意力全身心的投入到业务逻辑的数据处理上，而无需手动变动DOM的更新

33.6.3 - 指令

33.6.3.1 - 自定义属性，写在标签上以v-为前缀的特殊属性

33.6.3.2 - 预期的值为javascript表达式

33.6.3.3 - 作用是将数据和DOM做关联，当表达式的值改变时，响应式地作用于DOM上

33.6.4 - 常用指令一览

33.6.4.1 - v-bind：动态的绑定数据到DOM元素上，当数据发生变化，响应的更新DOM数据

33.6.4.2 - v-once：只渲染元素和组件一次，随后数据更新，并不会重新更新DOM数据，可视为静态内容，将渲染结果缓存起来，用于优化更新性能

33.6.4.3 - v-show：根据表达式之真假值，切换元素的 display CSS 属性

33.6.4.4 - v-if：根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建

33.6.4.5 - v-if、v-else-if、v-else：多重条件选择渲染

33.6.4.6 - v-for：基于源数据多次渲染元素或模板块；v-for默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 key 的特殊属性：

33.6.4.7 - v-model：随表单控件类型不同而不同，在表单控件或者组件上创建双向绑定

33.6.4.8 - v-cloak：以隐藏未编译的 Mustache 标签直到实例准备完毕

33.6.4.9 - v-once：只渲染元素和组件一次，这可以用于优化更新性能

33.6.4.10 - 自定义指令：除了核心功能默认内置的指令，也允许注册自定义指令

33.6.5 - 选项对象

33.6.5.1 - 在启动整个应用实例化时传入的参数。通过这些选项来创建想要的行为

33.6.5.2 - el（element）：提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标

33.6.5.3 - 数据类：

33.6.5.3.1 - data（数据）：应用的数据，可被转为getter/setter，能够响应数据的变化

33.6.5.3.2 - computed（计算属性）：将对data数据的逻辑抽离在计算属性中；这些属性依赖data的变化而相应；计算属性的结果会被缓存，多次使用不重新计算。

33.6.5.3.3 - methods（方法）：存放应用中封装的方法，例如事假处理函数

33.6.5.3.4 - watch（侦听属性）：当有一些数据需要随着其它数据变动而变动时，可通过watch侦听

33.6.5.3.5 - computed VS methods VS watch watch：这三者在某些功能点是重复的，何时使用使用在什么样的场景。

33.6.5.4 - 生命周期钩子函数

33.6.5.4 - 生命周期钩子函数

33.6.5.4.2 - created：实例创建完成后被立即调用，数据观测，计算属性，方法定义都已完成，但还没开始挂载。

33.6.5.4.3 - beforeMount：挂载开始之前被调用

33.6.5.4.4 - mounted：挂载之后调用该钩子函数

33.6.5.4.5 - beforeUpdate：数据更新时调用，可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程

33.6.5.4.6 - updated：数据更新之后调用该函数，当这个钩子被调用时，组件 DOM 已经更新

33.6.5.4.7 - beforeDestroy：实例销毁之前调用

33.6.5.4.8 - destroyed：实例销毁后调用，调用后实例中所有东西都会解除绑定，子实例也会被销毁

33.6.6 - 组件
        </div>
    </div>
<script>
    /*
        自定义滚动条
            1.比例公式
            2.事件对象的相关知识

    */
    const box1 = document.getElementById('div1');
    const box2 = document.getElementById('div2');
    const box3 = document.getElementById('div3');
    const box4 = document.getElementById('div4');

    box2.addEventListener('mousedown',function(ev){
        let disY = ev.pageY - this.offsetTop;

        let move = function(ev){
            let t = ev.pageY - disY;
            if(t < 0){
                t = 0;
            }else if(t > box1.clientHeight - box2.clientHeight){
                t = box1.clientHeight - box2.clientHeight;
            }
            
            let scale = t/(box1.clientHeight - box2.clientHeight)
            
            //div3的高度
            let box3H = box3.clientHeight;
            //div4的被内容撑开的高度
            let box4H = box4.scrollHeight;

            /*
                移动的距离 = (div3的高度 - div4的被内容撑开的高度 ) * (0-1之间的比例)

            */
            
            box4.style.top = scale * (box3H - box4H) + 'px';

            box2.style.top = t + 'px';
        }

        let up = function(){
            document.removeEventListener('mousemove',move);
            document.removeEventListener('mouseup',up);
        }

        document.addEventListener('mousemove',move);
        document.addEventListener('mouseup',up);
        ev.preventDefault();
    }); 

</script>
</body>
</html>